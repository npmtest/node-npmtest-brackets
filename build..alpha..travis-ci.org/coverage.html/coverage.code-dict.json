{"/home/travis/build/npmtest/node-npmtest-brackets/test.js":"/* istanbul instrument in package npmtest_brackets */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-brackets/lib.npmtest_brackets.js":"/* istanbul instrument in package npmtest_brackets */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_brackets = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_brackets = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-brackets/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-brackets && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_brackets */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_brackets\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_brackets.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_brackets.rollup.js'] =\n            local.assetsDict['/assets.npmtest_brackets.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_brackets.__dirname + '/lib.npmtest_brackets.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-brackets/node_modules/brackets/lib/server.js":"/*jshint -W086 */\n\n\"use strict\";\n\n// NOTE: Brackets doesn't fully support browsers yet and we need some workarounds. Workarounds will be marked with \"HACK:\" label.\n\nvar http        = require(\"http\"),\n    https       = require(\"https\"),\n    path        = require(\"path\"),\n    send        = require(\"send\"),\n    util        = require(\"util\"),\n    urlUtil     = require(\"url\"),\n    files       = require(\"./files\"),\n    domains     = require(\"./domains/socket\"),\n    socket      = require(\"socket.io\"),\n    brckDist    = {root: path.join(__dirname, \"..\", \"brackets-dist\")},\n    zipped      = { \".js\": \"application/javascript\", \".css\": \"text/css\"},\n    defaultPort = 6800;\n\nrequire(\"./shim\");\n\nfunction removeTrailingSlash(path) {\n    return path[path.length - 1] === \"/\" ? path.substr(0, path.length - 1) : path;\n}\n\nfunction createHttpServer(inst, port) {\n    inst.httpServer = http.createServer(function (req, res) {\n        if (req.url === \"/\") {\n            res.writeHead(302, {Location: inst.httpRoot + \"/\"});\n            res.end();\n        } else {\n            res.writeHead(304);\n            res.end(\"Not found\");\n        }\n    });\n    inst.io = socket(inst.httpServer);\n    inst.httpServer.listen(port);\n    console.log(util.format(\"\\n  listening on port %d\\n\", port));\n}\n\nfunction attachStatic(inst) {\n    var srv     = inst.httpServer,\n        root    = inst.httpRoot,\n        evs     = srv.listeners(\"request\").slice(0),\n        extDir  = { root: path.join(inst.supportDir, \"extensions\")} ;\n\n    srv.removeAllListeners(\"request\");\n    srv.on(\"request\", function(req, res) {\n        if (req.url.startsWith(root)) {\n            var url = req.url.substr(root.length);\n\n            if (url === \"\") {\n                res.writeHead(301, {Location: inst.httpRoot + \"/\"});\n                res.end();\n                return;\n            }\n\n            if (url === \"/\") {\n                url = \"/index.html\";\n            }\n\n            if (url.startsWith(\"/proxy/\")) {\n                var reqUrl      = decodeURIComponent(url.substr(\"/proxy/\".length)),\n                    options     = urlUtil.parse(reqUrl),\n                    httpClient  = options.protocol === \"http\" ? http : https;\n\n                delete options.protocol;\n                options.method = \"GET\";\n\n                req.pause();\n                var connector = httpClient.request(options, function(_res) {\n                    _res.pause();\n                    res.writeHead(_res.statusCode, _res.headers);\n                    _res.pipe(res);\n                    _res.resume();\n                });\n                req.pipe(connector);\n                req.resume();\n                return;\n            }\n\n            var cntType = zipped[path.extname(url)];\n            if (cntType) {\n                send(req, url + \".gz\", brckDist)\n                    .on(\"headers\", function (_res) {\n                        _res.setHeader(\"Content-Encoding\", \"gzip\");\n                        _res.setHeader(\"Content-Type\", cntType);\n                    })\n                    .pipe(res);\n                return;\n            }\n\n            send(req, url, brckDist).pipe(res);\n        } else if (req.url.startsWith(\"/support/extensions/\")) {\n            try {\n                return send(req, req.url.substr(\"/support/extensions\".length), extDir).pipe(res);\n            } catch (e) {\n                res.writeHead(500, {\n                    \"Content-Length\": e.message.length,\n                    \"Content-Type\": \"text/plain\"\n                });\n                res.end(e.message);\n            }\n        } else {\n            for (var i = 0; i < evs.length; i++) {\n                evs[i].call(srv, req, res);\n            }\n        }\n    });\n}\n\nfunction Server(srv, opts) {\n    if (!(this instanceof Server)) {\n        return new Server(srv, opts);\n    }\n\n    switch (typeof srv) {\n        case \"undefined\":\n        case \"null\":\n            createHttpServer(this, defaultPort);\n            break;\n        case \"object\":\n            if (srv instanceof socket) {\n                this.io = srv;\n                this.httpServer = srv.httpServer;\n            } else if (srv instanceof http.Server) {\n                this.httpServer = srv;\n                this.io = socket(this.httpServer);\n            } else {\n                opts = srv;\n                srv = null;\n                createHttpServer(this, defaultPort);\n            }\n            break;\n        case \"number\":\n        case \"string\":\n            createHttpServer(this, Number(srv));\n            break;\n        default:\n            throw \"Invalid argument – srv.\";\n    }\n\n    opts = opts || {};\n\n    this.httpRoot = removeTrailingSlash(opts.httpRoot || \"/brackets\");\n    this.defaultExtensions = path.join(brckDist.root, \"extensions\");\n    this.supportDir = removeTrailingSlash(opts.supportDir || path.resolve(\"./brackets\"));\n    this.projectsDir = removeTrailingSlash(opts.projectsDir || path.resolve(\"./projects\"));\n    this.samplesDir = removeTrailingSlash(opts.samplesDir || path.join(brckDist.root, \"samples\"));\n    this.allowUserDomains = opts.allowUserDomains || false;\n\n    switch (typeof opts.fileSystem) {\n        case \"string\":\n            // Reserved for future build-in providers.\n            this.fileSystem = require(\"./file-sys/\" + opts.fileSystem);\n            break;\n        case \"object\":\n            this.fileSystem = opts.fileSystem;\n            break;\n        case \"undefined\":\n        case \"null\":\n            this.fileSystem = require(\"./file-sys/native\");\n            break;\n        default:\n            throw new Error(\"Invalid fileSystem option.\");\n    }\n\n    var that = this;\n    this.fileSystem.mkdir(this.projectsDir, function (err) {\n        if (err && err.code !== \"EEXIST\") {\n            throw err;\n        }\n\n        attachStatic(that);\n\n        // Attach file system methods to socket.io.\n        files.init(that);\n\n        // Attach Brackets domians.\n        domains.init(that);\n    });\n}\n\nmodule.exports = Server;\n","/home/travis/build/npmtest/node-npmtest-brackets/node_modules/brackets/lib/files.js":"\"use strict\";\n\nfunction init(srv) {\n    var fs = srv.fileSystem;\n\n    function stat(req, callback) {\n        fs.resolvePath(req, srv, function (err, path) {\n            if (err) {\n                return callback({ err: err });\n            }\n\n            fs.stat(path, function (err, stats) {\n                callback(err ? { err: err } : { stats: stats });\n            });\n        });\n    }\n\n    function readdir(req, callback) {\n        fs.resolvePath(req, srv, function (err, path) {\n            if (err) {\n                return callback({ err: err });\n            }\n\n            fs.readdir(path, function (err, files) {\n                callback({ err: err, contents: files });\n            });\n        });\n    }\n\n    function mkdir(req, callback) {\n        fs.resolvePath(req.path, srv, function (err, path) {\n            if (err) {\n                return callback(err);\n            }\n\n            fs.mkdir(path, req.mode, callback);\n        });\n    }\n\n    function rename(req, callback) {\n        fs.resolvePath(req.oldPath, srv, function (err, oldPath) {\n            if (err) {\n                return callback(err);\n            }\n            fs.resolvePath(req.newPath, srv, function (err, newPath) {\n                if (err) {\n                    return callback(err);\n                }\n\n                fs.rename(oldPath, newPath, callback);\n            });\n        });\n    }\n\n    function readFile(req, callback) {\n        fs.resolvePath(req.path, srv, function (err, path) {\n            if (err) {\n                return callback({ err: err });\n            }\n\n            fs.readFile(path, req.encoding, function (err, data) {\n                callback({ err: err, data: data });\n            });\n        });\n    }\n\n    function writeFile(req, callback) {\n        fs.resolvePath(req.path, srv, function (err, path) {\n            if (err) {\n                return callback(err);\n            }\n\n            fs.writeFile(path, req.data, req.encoding, callback);\n        });\n    }\n\n    function unlink(req, callback) {\n        fs.resolvePath(req, srv, function (err, path) {\n            if (err) {\n                return callback(err);\n            }\n\n            fs.unlink(path, callback);\n        });\n    }\n\n    function moveToTrash(req, callback) {\n        fs.resolvePath(req, srv, function (err, path) {\n            if (err) {\n                return callback(err);\n            }\n\n            fs.moveToTrash(path, callback);\n        });\n    }\n\n    function watchPath(req, callback) {\n        fs.resolvePath(req, srv, function (err, path) {\n            if (err) {\n                return callback(err);\n            }\n\n            fs.watchPath(path, callback);\n        });\n    }\n\n    function unwatchPath(req, callback) {\n        fs.resolvePath(req, srv, function (err, path) {\n            if (err) {\n                return callback(err);\n            }\n\n            fs.unwatchPath(path, callback);\n        });\n    }\n\n    function unwatchAll(req, callback) {\n        fs.resolvePath(req, srv, function (err, path) {\n            if (err) {\n                return callback(err);\n            }\n\n            fs.unwatchAll(path, callback);\n        });\n    }\n\n    function copyFile(req, callback) {\n        fs.resolvePath(req.src, srv, function (err, src) {\n            if (err) {\n                return callback(err);\n            }\n            fs.resolvePath(req.dest, srv, function (err, dest) {\n                if (err) {\n                    return callback(err);\n                }\n\n                fs.rename(src, dest, callback);\n            });\n        });\n    }\n\n    function onConnection (socket) {\n        socket.emit(\"greeting\", \"hi\");\n\n        socket\n            .on(\"stat\", stat)\n            .on(\"mkdir\", mkdir)\n            .on(\"readdir\", readdir)\n            .on(\"rename\", rename)\n            .on(\"readFile\", readFile)\n            .on(\"writeFile\", writeFile)\n            .on(\"unlink\", unlink)\n            .on(\"moveToTrash\", moveToTrash)\n            .on(\"watchPath\", watchPath)\n            .on(\"unwatchPath\", unwatchPath)\n            .on(\"unwatchAll\", unwatchAll)\n            .on(\"copyFile\", copyFile);\n    }\n\n    srv.io\n        .of(srv.httpRoot)\n        .on(\"connection\", onConnection);\n}\n\nexports.init = init;\n","/home/travis/build/npmtest/node-npmtest-brackets/node_modules/brackets/lib/domains/socket.js":"\"use strict\";\n\nvar ConnectionManager = require(\"./ConnectionManager\"),\n    DomainManager     = require(\"./DomainManager\");\n\nfunction init(srv) {\n    var root = srv.httpRoot + \"-ext\",\n        apiUrl = root + \"/api\";\n\n    srv.httpServer.on(\"request\", function (req, res) {\n        if (req.url.startsWith(apiUrl)) {\n            res.setHeader(\"Content-Type\", \"application/json\");\n            res.end(\n                JSON.stringify(DomainManager.getDomainDescriptions(),\n                               null,\n                               4)\n            );\n        }\n    });\n\n    srv.io\n        .of(root)\n        .on(\"connection\", ConnectionManager.createConnection);\n\n    DomainManager.httpRoot = srv.httpRoot;\n    DomainManager.supportDir = srv.supportDir;\n    DomainManager.projectsDir = srv.projectsDir;\n    DomainManager.samplesDir = srv.samplesDir;\n    DomainManager.allowUserDomains = srv.allowUserDomains;\n    DomainManager.loadDomainModulesFromPaths([\"./BaseDomain\"]);\n}\n\nexports.init = init;\n","/home/travis/build/npmtest/node-npmtest-brackets/node_modules/brackets/lib/domains/ConnectionManager.js":"/*\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n */\n\n(function () {\n    \"use strict\";\n\n    var DomainManager = require(\"./DomainManager\");\n\n    /**\n     * @private\n     * @type{Array.<Connection>}\n     * Currently active connections\n     */\n    var _connections = [];\n\n    /**\n     * @private\n     * @constructor\n     * A WebSocket connection to a client. This is a private constructor.\n     * Callers should use the ConnectionManager.createConnection function\n     * instead.\n     * @param {WebSocket} ws The WebSocket representing the client\n     */\n    function Connection(ws) {\n        this._ws = ws;\n        this._connected = true;\n        this._ws.on(\"message\", this._receive.bind(this));\n        this._ws.on(\"close\", this.close.bind(this));\n    }\n\n    /**\n     * @private\n     * @type {boolean}\n     * Whether the connection is connected.\n     */\n    Connection.prototype._connected = false;\n\n    /**\n     * @private\n     * @type {WebSocket}\n     * The connection's WebSocket\n     */\n    Connection.prototype._ws = null;\n\n    /**\n     * @private\n     * Sends a message over the WebSocket. Called by public sendX commands.\n     * @param {string} type Message type. Currently supported types are\n         \"event\", \"commandResponse\", \"commandError\", \"error\"\n     * @param {object} message Message body, must be JSON.stringify-able\n     */\n    Connection.prototype._send = function (type, message) {\n        if (this._ws && this._connected) {\n            try {\n                this._ws.send(JSON.stringify({type: type, message: message}));\n            } catch (e) {\n                console.error(\"[Connection] Unable to stringify message: \" + e.message);\n            }\n        }\n    };\n\n    /**\n     * @private\n     * Sends a binary message over the WebSocket. Implicitly interpreted as a\n     * message of type \"commandResponse\".\n     * @param {Buffer} message\n     */\n    Connection.prototype._sendBinary = function (message) {\n        if (this._ws && this._connected) {\n            this._ws.send(message, {binary: true, mask: false});\n        }\n    };\n\n    /**\n     * @private\n     * Receive event handler for the WebSocket. Responsible for parsing\n     * message and handing it off to the appropriate handler.\n     * @param {string} message Message received by WebSocket\n     */\n    Connection.prototype._receive = function (message) {\n        var m;\n        try {\n            m = JSON.parse(message);\n        } catch (parseError) {\n            this.sendError(\"Unable to parse message: \" + message);\n            return;\n        }\n\n        if (m.id !== null && m.id !== undefined && m.domain && m.command) {\n            // okay if m.parameters is null/undefined\n            try {\n                DomainManager.executeCommand(this, m.id, m.domain,\n                                             m.command, m.parameters);\n            } catch (executionError) {\n                this.sendCommandError(m.id, executionError.message,\n                                      executionError.stack);\n            }\n        } else {\n            this.sendError(\"Malformed message: \" + message);\n        }\n    };\n\n    /**\n     * Closes the connection and does necessary cleanup\n     */\n    Connection.prototype.close = function () {\n        if (this._ws) {\n            try {\n                this._ws.close();\n            } catch (e) { }\n        }\n        this._connected = false;\n        _connections.splice(_connections.indexOf(this), 1);\n    };\n\n    /**\n     * Sends an Error message\n     * @param {object} message Error message. Must be JSON.stringify-able.\n     */\n    Connection.prototype.sendError = function (message) {\n        this._send(\"error\", {message: message});\n    };\n\n    /**\n     * Sends a response to a command execution\n     * @param {number} id unique ID of the command that was executed. ID is\n     *    generated by the client when the command is issued.\n     * @param {object|Buffer} response Result of the command execution. Must\n     *    either be JSON.stringify-able or a raw Buffer. In the latter case,\n     *    the result will be sent as a binary response.\n     */\n    Connection.prototype.sendCommandResponse = function (id, response) {\n        if (Buffer.isBuffer(response)) {\n            // Assume the id is an unsigned 32-bit integer, which is encoded\n            // as a four-byte header\n            var header = new Buffer(4);\n\n            header.writeUInt32LE(id, 0);\n\n            // Prepend the header to the message\n            var message = Buffer.concat([header, response], response.length + 4);\n\n            this._sendBinary(message);\n        } else {\n            this._send(\"commandResponse\", {id: id, response: response });\n        }\n    };\n\n    /**\n     * Sends a response indicating that an error occurred during command\n     * execution\n     * @param {number} id unique ID of the command that was executed. ID is\n     *    generated by the client when the command is issued.\n     * @param {string} message Error message\n     * @param {?object} stack Call stack from the exception, if possible. Must\n     *    be JSON.stringify-able.\n     */\n    Connection.prototype.sendCommandError = function (id, message, stack) {\n        this._send(\"commandError\", {id: id, message: message, stack: stack});\n    };\n\n    /**\n     * Sends an event message\n     * @param {number} id unique ID for the event.\n     * @param {string} domain Domain of the event.\n     * @param {string} event Name of the event\n     * @param {object} parameters Event parameters. Must be JSON.stringify-able.\n     */\n    Connection.prototype.sendEventMessage =\n        function (id, domain, event, parameters) {\n        this._send(\"event\", {id: id,\n                             domain: domain,\n                             event: event,\n                             parameters: parameters\n                            });\n    };\n\n    /**\n     * Factory function for creating a new Connection\n     * @param {WebSocket} ws The WebSocket connected to the client.\n     */\n    function createConnection(ws) {\n        _connections.push(new Connection(ws));\n    }\n\n    /**\n     * Closes all connections gracefully. Should be called during shutdown.\n     */\n    function closeAllConnections() {\n        var i;\n        for (i = 0; i < _connections.length; i++) {\n            try {\n                _connections[i].close();\n            } catch (err) { }\n        }\n        _connections = [];\n    }\n\n    /**\n     * Sends all open connections the specified event\n     * @param {number} id unique ID for the event.\n     * @param {string} domain Domain of the event.\n     * @param {string} event Name of the event\n     * @param {object} parameters Event parameters. Must be JSON.stringify-able.\n     */\n    function sendEventToAllConnections(id, domain, event, parameters) {\n        _connections.forEach(function (c) {\n            c.sendEventMessage(id, domain, event, parameters);\n        });\n    }\n\n    exports.createConnection          = createConnection;\n    exports.closeAllConnections       = closeAllConnections;\n    exports.sendEventToAllConnections = sendEventToAllConnections;\n}());\n","/home/travis/build/npmtest/node-npmtest-brackets/node_modules/brackets/lib/domains/DomainManager.js":"/*\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n */\n\n(function () {\n    \"use strict\";\n\n    var util                = require(\"util\"),\n        domain              = require(\"domain\"),\n        ConnectionManager   = require(\"./ConnectionManager\");\n\n    /**\n     * @constructor\n     * DomainManager is a module/class that handles the loading, registration,\n     * and execution of all commands and events. It is a singleton, and is passed\n     * to a domain in its init() method.\n     */\n    var self = exports;\n\n    /**\n     * @private\n     * @type {object}\n     * Map of all the registered domains\n     */\n    var _domains = {};\n\n    /**\n     * @private\n     * @type {Array.<Module>}\n     * Array of all modules we have loaded. Used for avoiding duplicate loading.\n     */\n    var _initializedDomainModules = [];\n\n    /**\n     * @private\n     * @type {number}\n     * Used for generating unique IDs for events.\n     */\n    var _eventCount = 1;\n\n    /**\n     * @private\n     * @type {Array}\n     * JSON.stringify-able Array of the current API. In the format of\n     * Inspector.json. This is a cache that we invalidate every time the\n     * API changes.\n     */\n    var _cachedDomainDescriptions = null;\n\n    /**\n     * Returns whether a domain with the specified name exists or not.\n     * @param {string} domainName The domain name.\n     * @return {boolean} Whether the domain exists\n     */\n    function hasDomain(domainName) {\n        return !!_domains[domainName];\n    }\n\n    /**\n     * Returns a new empty domain. Throws error if the domain already exists.\n     * @param {string} domainName The domain name.\n     * @param {{major: number, minor: number}} version The domain version.\n     *   The version has a format like {major: 1, minor: 2}. It is reported\n     *   in the API spec, but serves no other purpose on the server. The client\n     *   can make use of this.\n     */\n    function registerDomain(domainName, version) {\n        if (!hasDomain(domainName)) {\n            // invalidate the cache\n            _cachedDomainDescriptions = null;\n\n            _domains[domainName] = {version: version, commands: {}, events: {}};\n        } else {\n            console.error(\"[DomainManager] Domain \" + domainName + \" already registered\");\n        }\n    }\n\n    /**\n     * Registers a new command with the specified domain. If the domain does\n     * not yet exist, it registers the domain with a null version.\n     * @param {string} domainName The domain name.\n     * @param {string} commandName The command name.\n     * @param {Function} commandFunction The callback handler for the function.\n     *    The function is called with the arguments specified by the client in the\n     *    command message. Additionally, if the command is asynchronous (isAsync\n     *    parameter is true), the function is called with an automatically-\n     *    constructed callback function of the form cb(err, result). The function\n     *    can then use this to send a response to the client asynchronously.\n     * @param {boolean} isAsync See explanation for commandFunction param\n     * @param {?string} description Used in the API documentation\n     * @param {?Array.<{name: string, type: string, description:string}>} parameters\n     *    Used in the API documentation.\n     * @param {?Array.<{name: string, type: string, description:string}>} returns\n     *    Used in the API documentation.\n     */\n    function registerCommand(domainName, commandName, commandFunction, isAsync,\n                              description, parameters, returns) {\n        // invalidate the cache\n        _cachedDomainDescriptions = null;\n\n        if (!hasDomain(domainName)) {\n            registerDomain(domainName, null);\n        }\n\n        if (!_domains[domainName].commands[commandName]) {\n            _domains[domainName].commands[commandName] = {\n                commandFunction: commandFunction,\n                isAsync: isAsync,\n                description: description,\n                parameters: parameters,\n                returns: returns\n            };\n        } else {\n            throw new Error(\"Command \" + domainName + \".\" +\n                            commandName + \" already registered\");\n        }\n    }\n\n    /**\n     * Executes a command by domain name and command name. Called by a connection's\n     * message parser. Sends response or error (possibly asynchronously) to the\n     * connection.\n     * @param {Connection} connection The requesting connection object.\n     * @param {number} id The unique command ID.\n     * @param {string} domainName The domain name.\n     * @param {string} commandName The command name.\n     * @param {Array} parameters The parameters to pass to the command function. If\n     *    the command is asynchronous, will be augmented with a callback function.\n     *    (see description in registerCommand documentation)\n     */\n    function executeCommand(connection, id, domainName,\n                             commandName, parameters) {\n        var el, i;\n\n        for (i = 0; i < parameters.length; i++) {\n            el = parameters[i];\n            if (typeof el === \"string\") {\n                if  (el.startsWith(\"/projects/\")) {\n                    parameters[i] = exports.projectsDir + el.substr(\"/projects\".length);\n                } else if  (el.startsWith(\"/samples/\")) {\n                    parameters[i] = exports.samplesDir + el.substr(\"/samples\".length);\n                }\n            }\n        }\n\n        if (_domains[domainName] &&\n            _domains[domainName].commands[commandName]) {\n            var command = _domains[domainName].commands[commandName];\n            if (command.isAsync) {\n                var execDom     = domain.create(),\n                    callback    = function (err, result) {\n                        if (err) {\n                            connection.sendCommandError(id, err);\n                        } else {\n                            connection.sendCommandResponse(id, result);\n                        }\n                    };\n\n                parameters.push(callback);\n\n                execDom.on(\"error\", function(err) {\n                    connection.sendCommandError(id, err.message);\n                    execDom.dispose();\n                });\n\n                execDom.bind(command.commandFunction).apply(connection, parameters);\n            } else { // synchronous command\n                try {\n                    connection.sendCommandResponse(\n                        id,\n                        command.commandFunction.apply(connection, parameters)\n                    );\n                } catch (e) {\n                    connection.sendCommandError(id, e.message);\n                }\n            }\n        } else {\n            connection.sendCommandError(id, \"no such command: \" +\n                                        domainName + \".\" + commandName);\n        }\n    }\n\n    /**\n     * Registers an event domain and name.\n     * @param {string} domainName The domain name.\n     * @param {string} eventName The event name.\n     * @param {?Array.<{name: string, type: string, description:string}>} parameters\n     *    Used in the API documentation.\n     */\n    function registerEvent(domainName, eventName, parameters) {\n        // invalidate the cache\n        _cachedDomainDescriptions = null;\n\n        if (!hasDomain(domainName)) {\n            registerDomain(domainName, null);\n        }\n\n        if (!_domains[domainName].events[eventName]) {\n            _domains[domainName].events[eventName] = {\n                parameters: parameters\n            };\n        } else {\n            console.error(\"[DomainManager] Event \" + domainName + \".\" +\n                          eventName + \" already registered\");\n        }\n    }\n\n    /**\n     * Emits an event with the specified name and parameters to all connections.\n     *\n     * TODO: Future: Potentially allow individual connections to register\n     * for which events they want to receive. Right now, we have so few events\n     * that it's fine to just send all events to everyone and decide on the\n     * client side if the client wants to handle them.\n     *\n     * @param {string} domainName The domain name.\n     * @param {string} eventName The event name.\n     * @param {?Array} parameters The parameters. Must be JSON.stringify-able\n     */\n    function emitEvent(domainName, eventName, parameters) {\n        if (_domains[domainName] && _domains[domainName].events[eventName]) {\n            ConnectionManager.sendEventToAllConnections(\n                _eventCount++,\n                domainName,\n                eventName,\n                parameters\n            );\n        } else {\n            console.error(\"[DomainManager] No such event: \" + domainName +\n                          \".\" + eventName);\n        }\n    }\n\n    /**\n     * Loads and initializes domain modules using the specified paths. Checks to\n     * make sure that a module is not loaded/initialized more than once.\n     *\n     * @param {Array.<string>} paths The paths to load. The paths can be relative\n     *    to the DomainManager or absolute. However, modules that aren't in core\n     *    won't know where the DomainManager module is, so in general, all paths\n     *    should be absolute.\n     * @return {boolean} Whether loading succeded. (Failure will throw an exception).\n     */\n    function loadDomainModulesFromPaths(paths) {\n        var pathArray = paths;\n        if (!util.isArray(paths)) {\n            pathArray = [paths];\n        }\n        pathArray.forEach(function (path) {\n            if (path.startsWith(exports.httpRoot)) {\n                path = \"../../brackets-srv\" + path.substr(exports.httpRoot.length);\n            } else if (path.startsWith(\"/support/extensions/user/\")) {\n                if (exports.allowUserDomains) {\n                    path = exports.supportDir + path.substr(\"/support\".length);\n                } else {\n                    console.error(\"ERROR: User domains are not allowed: \" + path);\n                    return false;\n                }\n            } else if (path !== \"./BaseDomain\") {\n                console.error(\"ERROR: Invalid domain path: \" + path);\n                return false;\n            }\n\n            try {\n                var m = require(path);\n                if (m && m.init && _initializedDomainModules.indexOf(m) < 0) {\n                    m.init(self);\n                    _initializedDomainModules.push(m); // don't init more than once\n                }\n            } catch (err) {\n                console.error(err);\n                return false;\n            }\n        });\n        return true; // if we fail, an exception will be thrown\n    }\n\n    /**\n     * Returns a description of all registered domains in the format of WebKit's\n     * Inspector.json. Used for sending API documentation to clients.\n     *\n     * @return {Array} Array describing all domains.\n     */\n    function getDomainDescriptions() {\n        if (!_cachedDomainDescriptions) {\n            _cachedDomainDescriptions = [];\n\n            var domainNames = Object.keys(_domains);\n            domainNames.forEach(function (domainName) {\n                var d = {\n                    domain: domainName,\n                    version: _domains[domainName].version,\n                    commands: [],\n                    events: []\n                };\n                var commandNames = Object.keys(_domains[domainName].commands);\n                commandNames.forEach(function (commandName) {\n                    var c = _domains[domainName].commands[commandName];\n                    d.commands.push({\n                        name: commandName,\n                        description: c.description,\n                        parameters: c.parameters,\n                        returns: c.returns\n                    });\n                });\n                var eventNames = Object.keys(_domains[domainName].events);\n                eventNames.forEach(function (eventName) {\n                    d.events.push({\n                        name: eventName,\n                        parameters: _domains[domainName].events[eventName].parameters\n                    });\n                });\n                _cachedDomainDescriptions.push(d);\n            });\n        }\n        return _cachedDomainDescriptions;\n    }\n\n    exports.hasDomain                  = hasDomain;\n    exports.registerDomain             = registerDomain;\n    exports.registerCommand            = registerCommand;\n    exports.executeCommand             = executeCommand;\n    exports.registerEvent              = registerEvent;\n    exports.emitEvent                  = emitEvent;\n    exports.loadDomainModulesFromPaths = loadDomainModulesFromPaths;\n    exports.getDomainDescriptions      = getDomainDescriptions;\n}());\n","/home/travis/build/npmtest/node-npmtest-brackets/node_modules/brackets/lib/shim.js":"\"use strict\";\n\nif (!String.prototype.startsWith) {\n    var toString = {}.toString;\n    String.prototype.startsWith = function (search){\n        if (this === null) {\n            throw new TypeError();\n        }\n        var string = String(this);\n        if (search && toString.call(search) === \"[object RegExp]\") {\n            throw new TypeError();\n        }\n        var stringLength = string.length;\n        var searchString = String(search);\n        var searchLength = searchString.length;\n        var position = arguments.length > 1 ? arguments[1] : undefined;\n\n        var pos = position ? Number(position) : 0;\n        if (pos !== pos) {\n            pos = 0;\n        }\n        var start = Math.min(Math.max(pos, 0), stringLength);\n\n        if (searchLength + start > stringLength) {\n            return false;\n        }\n        var index = -1;\n        while (++index < searchLength) {\n            if (string.charCodeAt(start + index) !== searchString.charCodeAt(index)) {\n                return false;\n            }\n        }\n        return true;\n    };\n}\n","/home/travis/build/npmtest/node-npmtest-brackets/node_modules/brackets/index.js":"module.exports = require(\"./lib/server\");\n","/home/travis/build/npmtest/node-npmtest-brackets/node_modules/brackets/bin/run.js":"#!/usr/bin/env node\n\nvar commander   = require(\"commander\"),\n    brackets    = require(\"../\"),\n    pkg         = require(\"../package.json\"),\n    open        = require(\"open\"),\n    path        = require(\"path\"),\n    homeDir     = process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE || process.cwd();\n\ncommander\n    .version(pkg.version)\n    .option(\"-p, --port <port>\", \"Specifies TCP <port> for Brackets service. The default port is 6800.\")\n    .option(\"-o, --open\", \"Opens Brackets in the default web browser.\")\n    .option(\"-s, --supp-dir <path>\", \"Specifies the root directory for Brackets supporting files such as user extensions, configurations and state persistence. The default locations is ~/.brackets-srv.\")\n    .option(\"-j, --proj-dir <path>\", \"Specifies the root directory for projects. The default locations is ~/Projects.\")\n    .option(\"-d, --user-domains\", \"Allows Node domains to be loaded from user extensions.\")\n    .parse(process.argv);\n\nvar app = brackets(commander.port, {\n    supportDir: commander.suppDir || path.join(homeDir, \".brackets-srv\"),\n    projectsDir: commander.projDir || path.join(homeDir, \"Projects\"),\n    allowUserDomains: commander.userDomains\n});\n\nif (commander.open) {\n    open(\"http://localhost:\" + app.httpServer.address().port);\n}\n","/home/travis/build/npmtest/node-npmtest-brackets/node_modules/brackets/lib/file-sys/native.js":"\"use strict\";\n\nvar fs          = require(\"fs\"),\n    ncp         = require(\"ncp\"),\n    mkdirp      = require(\"mkdirp\"),\n    rimraf      = require(\"rimraf\"),\n    pathUtil    = require(\"path\"),\n    suppRoot    = \"/support/\",\n    sampRoot    = \"/samples/\",\n    projRoot    = \"/projects/\";\n\nfunction resolvePath(reqPath, context, callback) {\n    var extRoot = context.httpRoot + \"/extensions/\",\n        userExt = context.httpRoot + \"/extensions/user\",\n        root,\n        err,\n        res;\n\n    if (reqPath.startsWith(projRoot)) {\n        root = context.projectsDir;\n        res = pathUtil.join(root, reqPath.substr(projRoot.length));\n    } else if (reqPath.startsWith(userExt)) {\n        root = context.supportDir + \"/extensions/user\";\n        res = pathUtil.join(root, reqPath.substr(userExt.length));\n    } else if (reqPath.startsWith(extRoot)) {\n        root = context.defaultExtensions;\n        res = pathUtil.join(context.defaultExtensions, reqPath.substr(extRoot.length));\n    } else if (reqPath.startsWith(suppRoot)) {\n        root = context.supportDir;\n        res = pathUtil.join(context.supportDir, reqPath.substr(suppRoot.length));\n    } else if (reqPath.startsWith(sampRoot)) {\n        root = context.samplesDir;\n        res = pathUtil.join(context.samplesDir, reqPath.substr(sampRoot.length));\n    } else {\n        err = new Error(\"No such file or directory.\");\n        err.code = \"ENOENT\";\n        return callback(err);\n    }\n\n    if (res.substr(0, root.length) !== root) {\n        err = new Error(\"Permission denied.\");\n        err.code = \"EACCES\";\n        callback(err);\n    } else {\n        callback(null, res);\n    }\n}\n\nfunction stat(path, callback) {\n    fs.stat(path, function (err, stats) {\n        if (err) {\n            return callback(err);\n        }\n\n        callback(null, {\n            isFile: stats.isFile(),\n            mtime: stats.mtime,\n            size: stats.size,\n            realPath: null, // TODO: Set real path if symbolic link.\n            hash: stats.mtime.getTime()\n        });\n    });\n}\n\nfunction readdir(path, callback) {\n    fs.readdir(path, callback);\n}\n\nfunction mkdir(path, mode, callback) {\n    mkdirp(path, { mode: mode }, callback);\n}\n\nfunction rename(oldPath, newPath, callback) {\n    fs.rename(oldPath, newPath, callback);\n}\n\nfunction readFile(path, encoding, callback) {\n    fs.readFile(path, { encoding: encoding }, callback);\n}\n\nfunction writeFile(path, data, encoding, callback) {\n    fs.writeFile(path, data, { encoding: encoding }, callback);\n}\n\nfunction unlink(path, callback) {\n    rimraf(path, callback);\n}\n\nfunction moveToTrash(path, callback) {\n    rimraf(path, callback);\n}\n\nfunction watchPath(req, callback) {\n    callback();\n}\n\nfunction unwatchPath(req, callback) {\n    callback();\n}\n\nfunction unwatchAll(req, callback) {\n    callback();\n}\n\nfunction copyFile(src, dest, callback) {\n    ncp(src, dest, callback);\n}\n\nexports.resolvePath = resolvePath;\nexports.stat = stat;\nexports.readdir = readdir;\nexports.mkdir = mkdir;\nexports.rename = rename;\nexports.readFile = readFile;\nexports.writeFile = writeFile;\nexports.unlink = unlink;\nexports.moveToTrash = moveToTrash;\nexports.watchPath = watchPath;\nexports.unwatchPath = unwatchPath;\nexports.unwatchAll = unwatchAll;\nexports.copyFile = copyFile;\n","/home/travis/build/npmtest/node-npmtest-brackets/node_modules/brackets/lib/post-install.js":"\"use strict\";\n\nvar fs      = require(\"fs\"),\n    path    = require(\"path\"),\n    glob    = require(\"glob\"),\n    opts    = {\n        cwd: path.join(__dirname, \"..\", \"brackets-srv\")\n    };\n\nglob(\"**/node_modules_\", opts, function (err, files) {\n    if (err) {\n        throw err;\n    }\n\n    if (files) {\n        files.sort(function (a, b) {\n            return  b.length - a.length;\n        });\n\n        files.forEach(function (file) {\n            file = path.join(opts.cwd, file);\n            fs.renameSync(file, file.substr(0, file.length - 1));\n            console.log(\"file: \" + file.substr(0, file.length - 1));\n        });\n    }\n});\n","/home/travis/build/npmtest/node-npmtest-brackets/node_modules/brackets/lib/pre-publish.js":"\"use strict\";\n\nvar fs      = require(\"fs\"),\n    path    = require(\"path\"),\n    glob    = require(\"glob\"),\n    opts    = {\n        cwd: path.join(__dirname, \"..\", \"brackets-srv\")\n    },\n    logFile = \"./install.log\",\n    exists  = fs.existsSync(logFile),\n    conts;\n\nif (exists) {\n    conts = fs.readFileSync(logFile, { encoding: \"utf8\" });\n    fs.unlinkSync(logFile);\n}\n\nif (!conts) {\n    glob(\"**/node_modules\", opts, function (err, files) {\n        if (err) {\n            throw err;\n        }\n\n        if (files) {\n            files.sort(function (a, b) {\n                return  b.length - a.length;\n            });\n\n            files.forEach(function (file) {\n                file = path.join(opts.cwd, file);\n                fs.renameSync(file, file + \"_\");\n                console.log(\"file: \" + file + \"_\");\n            });\n        }\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-brackets/node_modules/brackets/lib/domains/BaseDomain.js":"/*\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n */\n\n(function () {\n    \"use strict\";\n\n    var //Launcher = require(\"./Launcher\"),\n        Logger   = require(\"./Logger\");\n\n    /**\n     * @private\n     * @type {DomainManager}\n     * DomainManager provided at initialization time\n     */\n    var _domainManager = null;\n\n    /**\n     * @private\n     * Implementation of base.enableDebugger commnad.\n     * In the future, process._debugProcess may go away. In that case\n     * we will probably have to implement re-launching of the Node process\n     * with the --debug command line switch.\n     */\n    function cmdEnableDebugger() {\n        // Unfortunately, there's no indication of whether this succeeded\n        // This is the case for _all_ of the methods for enabling the debugger.\n        process._debugProcess(process.pid);\n    }\n\n    /**\n     * @private\n     * Implementation of base.restartNode command.\n     */\n    function cmdRestartNode() {\n//        Launcher.exit();\n    }\n\n    /**\n     * @private\n     * Implementation of base.loadDomainModulesFromPaths\n     * @param {Array.<string>} paths Paths to load\n     * @return {boolean} Whether the load succeeded\n     */\n    function cmdLoadDomainModulesFromPaths(paths) {\n        if (_domainManager) {\n            var success = _domainManager.loadDomainModulesFromPaths(paths);\n            if (success) {\n                _domainManager.emitEvent(\"base\", \"newDomains\");\n            }\n            return success;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     *\n     * Registers commands with the DomainManager\n     * @param {DomainManager} domainManager The DomainManager to use\n     */\n    function init(domainManager) {\n        _domainManager = domainManager;\n\n        _domainManager.registerDomain(\"base\", {major: 0, minor: 1});\n        _domainManager.registerCommand(\n            \"base\",\n            \"enableDebugger\",\n            cmdEnableDebugger,\n            false,\n            \"Attempt to enable the debugger\",\n            [], // no parameters\n            []  // no return type\n        );\n        _domainManager.registerCommand(\n            \"base\",\n            \"restartNode\",\n            cmdRestartNode,\n            false,\n            \"Attempt to restart the Node server\",\n            [], // no parameters\n            []  // no return type\n        );\n        _domainManager.registerCommand(\n            \"base\",\n            \"loadDomainModulesFromPaths\",\n            cmdLoadDomainModulesFromPaths,\n            false,\n            \"Attempt to load command modules from the given paths. \" +\n            \"The paths should be absolute.\",\n            [{name: \"paths\", type: \"array<string>\"}],\n            [{name: \"success\", type: \"boolean\"}]\n        );\n\n        _domainManager.registerEvent(\n            \"base\",\n            \"log\",\n            [{name: \"level\", type: \"string\"},\n             {name: \"timestamp\", type: \"Date\"},\n             {name: \"message\", type: \"string\"}]\n        );\n        Logger.on(\n            \"log\",\n            function (level, timestamp, message) {\n                _domainManager.emitEvent(\n                    \"base\",\n                    \"log\",\n                    [level, timestamp, message]\n                );\n            }\n        );\n\n        _domainManager.registerEvent(\"base\", \"newDomains\", []);\n    }\n\n    exports.init = init;\n\n}());\n","/home/travis/build/npmtest/node-npmtest-brackets/node_modules/brackets/lib/domains/Logger.js":"/*\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n */\n\n(function () {\n    \"use strict\";\n\n    var fs           = require(\"fs\"),\n        util         = require(\"util\"),\n        EventEmitter = require(\"events\").EventEmitter;\n\n    /**\n     * @constructor\n     * The Logger module is a singleton object used for logging.\n     * Logger inherits from the EventEmitter class and exports itself\n     * as the module.\n     */\n    var Logger = module.exports = new EventEmitter();\n\n    /**\n     * @private\n     * @type{?string}\n     * Filename to append all log data to.\n     */\n    var _logFilename = null;\n\n    /**\n     * @private\n     * @type{Array.<{level: string, timestamp: Date, message: string}>}\n     * Complete log history\n     */\n    var _logHistory = [];\n\n    /**\n     * @private\n     * Helper function for logging functions. Handles string formatting.\n     * @param {string} level Log level (\"log\", \"info\", etc.)\n     * @param {Array.<Object>} Array of objects for logging. Works identically\n     *    to how objects can be passed to console.log. Uses util.format to\n     *    format into a single string.\n     */\n    function logReplacement(level, args) {\n        var message = util.format.apply(null, args);\n        var timestamp = new Date();\n        if (_logFilename) {\n            try {\n                var timestampString =\n                    \"[\" + level + \": \" +\n                    timestamp.toLocaleTimeString() + \"] \";\n\n                fs.appendFileSync(_logFilename,\n                                  timestampString + message + \"\\n\");\n            } catch (e) { }\n        }\n        _logHistory.push({\n            level: level,\n            timestamp: timestamp,\n            message: message\n        });\n        Logger.emit(\"log\", level, timestamp, message);\n    }\n\n    /**\n     * Log a \"log\" message\n     * @param {...Object} log arguments as in console.log etc.\n     *    First parameter can be a \"format\" string.\n     */\n    function log() { logReplacement(\"log\", arguments); }\n\n    /**\n     * Log an \"info\" message\n     * @param {...Object} log arguments as in console.log etc.\n     *    First parameter can be a \"format\" string.\n     */\n    function info() { logReplacement(\"info\", arguments); }\n\n    /**\n     * Log a \"warn\" message\n     * @param {...Object} log arguments as in console.log etc.\n     *    First parameter can be a \"format\" string.\n     */\n    function warn() { logReplacement(\"warn\", arguments); }\n\n    /**\n     * Log an \"error\" message\n     * @param {...Object} log arguments as in console.log etc.\n     *    First parameter can be a \"format\" string.\n     */\n    function error() { logReplacement(\"error\", arguments); }\n\n    /**\n     * Log a \"dir\" message\n     * @param {...Object} log arguments as in console.dir\n     *    Note that (just like console.dir) this does NOT do string\n     *    formatting using the first argument.\n     */\n    function dir() {\n        // dir does not do optional string formatting\n        var args = Array.prototype.slice.call(arguments, 0);\n        args.unshift(\"%s\");\n        logReplacement(\"dir\", args);\n    }\n\n    /**\n     * Remaps the console.log, etc. functions to the logging functions\n     * defined in this module. Useful so that modules can simply call\n     * console.log to call into this Logger (since client doesn't have)\n     * access to stdout.\n     */\n    function remapConsole() {\n        // Reassign logging functions to our logger\n        // NOTE: console.timeEnd uses console.log and console.trace uses\n        // console.error, so we don't need to change it explicitly\n        console.log   = log;\n        console.info  = info;\n        console.warn  = warn;\n        console.error = error;\n        console.dir   = dir;\n    }\n\n    /**\n     * Retrieves the entire log history\n     * @return {Array.<{level: string, timestamp: Date, message: string}>}\n     */\n    function getLogHistory(count) {\n        if (count === null) {\n            count = 0;\n        }\n        return _logHistory.slice(-count);\n    }\n\n    /**\n     * Sets the filename to which the log messages are appended.\n     * Specifying a null filename will turn off logging to a file.\n     * @param {?string} filename The filename.\n     */\n    function setLogFilename(filename) {\n        _logFilename = filename;\n    }\n\n    // Public interface\n    Logger.log            = log;\n    Logger.info           = info;\n    Logger.warn           = warn;\n    Logger.error          = error;\n    Logger.dir            = dir;\n    Logger.remapConsole   = remapConsole;\n    Logger.getLogHistory  = getLogHistory;\n    Logger.setLogFilename = setLogFilename;\n\n}());\n","/home/travis/build/npmtest/node-npmtest-brackets/node_modules/brackets/lib/domains/ExtensionManagerDomain.js":"/*\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n */\n\n\n/*jslint vars: true, plusplus: true, devel: true, node: true, nomen: true,\nindent: 4, maxerr: 50 */\n\n\"use strict\";\n\nvar supportDir;\n\nvar semver   = require(\"semver\"),\n    path     = require(\"path\"),\n    http     = require(\"http\"),\n    request  = require(\"request\"),\n    os       = require(\"os\"),\n    fs       = require(\"fs-extra\"),\n    temp     = require(\"temp\"),\n    validate = require(\"./package-validator\").validate;\n\n// Automatically clean up temp files on exit\ntemp.track();\n\nvar Errors = {\n    API_NOT_COMPATIBLE: \"API_NOT_COMPATIBLE\",\n    MISSING_REQUIRED_OPTIONS: \"MISSING_REQUIRED_OPTIONS\",\n    DOWNLOAD_ID_IN_USE: \"DOWNLOAD_ID_IN_USE\",\n    BAD_HTTP_STATUS: \"BAD_HTTP_STATUS\",             // {0} is the HTTP status code\n    NO_SERVER_RESPONSE: \"NO_SERVER_RESPONSE\",\n    CANNOT_WRITE_TEMP: \"CANNOT_WRITE_TEMP\",\n    CANCELED: \"CANCELED\"\n};\n\nvar Statuses = {\n    FAILED: \"FAILED\",\n    INSTALLED: \"INSTALLED\",\n    ALREADY_INSTALLED: \"ALREADY_INSTALLED\",\n    SAME_VERSION: \"SAME_VERSION\",\n    OLDER_VERSION: \"OLDER_VERSION\",\n    NEEDS_UPDATE: \"NEEDS_UPDATE\",\n    DISABLED: \"DISABLED\"\n};\n\n/**\n * Maps unique download ID to info about the pending download. No entry if download no longer pending.\n * outStream is only present if we've started receiving the body.\n * @type {Object.<string, {request:!http.ClientRequest, callback:!function(string, string), localPath:string, outStream:?fs.WriteStream}>}\n */\nvar pendingDownloads = {};\n\n/**\n * Private function to remove the installation directory if the installation fails.\n * This does not call any callbacks. It's assumed that the callback has already been called\n * and this cleanup routine will do its best to complete in the background. If there's\n * a problem here, it is simply logged with console.error.\n *\n * @param {string} installDirectory Directory to remove\n */\nfunction _removeFailedInstallation(installDirectory) {\n    fs.remove(installDirectory, function (err) {\n        if (err) {\n            console.error(\"Error while removing directory after failed installation\", installDirectory, err);\n        }\n    });\n}\n\n/**\n * Private function to unzip to the correct directory.\n *\n * @param {string} Absolute path to the package zip file\n * @param {string} Absolute path to the destination directory for unzipping\n * @param {Object} the return value with the useful information for the client\n * @param {Function} callback function that is called at the end of the unzipping\n */\nfunction _performInstall(packagePath, installDirectory, validationResult, callback) {\n    validationResult.installedTo = installDirectory;\n\n    var callbackCalled = false;\n\n    fs.mkdirs(installDirectory, function (err) {\n        if (err) {\n            callback(err);\n            return;\n        }\n        var sourceDir = path.join(validationResult.extractDir, validationResult.commonPrefix);\n\n        fs.copy(sourceDir, installDirectory, function (err) {\n            if (err) {\n                _removeFailedInstallation(installDirectory);\n                callback(err, null);\n            } else {\n                // The status may have already been set previously (as in the\n                // DISABLED case.\n                if (!validationResult.installationStatus) {\n                    validationResult.installationStatus = Statuses.INSTALLED;\n                }\n                callback(null, validationResult);\n            }\n        });\n    });\n}\n\n/**\n * Private function to remove the target directory and then install.\n *\n * @param {string} Absolute path to the package zip file\n * @param {string} Absolute path to the destination directory for unzipping\n * @param {Object} the return value with the useful information for the client\n * @param {Function} callback function that is called at the end of the unzipping\n */\nfunction _removeAndInstall(packagePath, installDirectory, validationResult, callback) {\n    // If this extension was previously installed but disabled, we will overwrite the\n    // previous installation in that directory.\n    fs.remove(installDirectory, function (err) {\n        if (err) {\n            callback(err);\n            return;\n        }\n        _performInstall(packagePath, installDirectory, validationResult, callback);\n    });\n}\n\nfunction _checkExistingInstallation(validationResult, installDirectory, systemInstallDirectory, callback) {\n    // If the extension being installed does not have a package.json, we can't\n    // do any kind of version comparison, so we just signal to the UI that\n    // it already appears to be installed.\n    if (!validationResult.metadata) {\n        validationResult.installationStatus = Statuses.ALREADY_INSTALLED;\n        callback(null, validationResult);\n        return;\n    }\n\n    fs.readJson(path.join(installDirectory, \"package.json\"), function (err, packageObj) {\n        // if the package.json is unreadable, we assume that the new package is an update\n        // that is the first to include a package.json.\n        if (err) {\n            validationResult.installationStatus = Statuses.NEEDS_UPDATE;\n        } else {\n            // Check to see if the version numbers signal an update.\n            if (semver.lt(packageObj.version, validationResult.metadata.version)) {\n                validationResult.installationStatus = Statuses.NEEDS_UPDATE;\n            } else if (semver.gt(packageObj.version, validationResult.metadata.version)) {\n                // Pass a message back to the UI that the new package appears to be an older version\n                // than what's installed.\n                validationResult.installationStatus = Statuses.OLDER_VERSION;\n                validationResult.installedVersion = packageObj.version;\n            } else {\n                // Signal to the UI that it looks like the user is re-installing the\n                // same version.\n                validationResult.installationStatus = Statuses.SAME_VERSION;\n            }\n        }\n        callback(null, validationResult);\n    });\n}\n\n/**\n * A \"legacy package\" is an extension that was installed based on the GitHub name without\n * a package.json file. Checking for the presence of these legacy extensions will help\n * users upgrade if the extension developer puts a different name in package.json than\n * the name of the GitHub project.\n *\n * @param {string} legacyDirectory directory to check for old-style extension.\n */\nfunction legacyPackageCheck(legacyDirectory) {\n    return fs.existsSync(legacyDirectory) && !fs.existsSync(path.join(legacyDirectory, \"package.json\"));\n}\n\n/**\n * Implements the \"install\" command in the \"extensions\" domain.\n *\n * There is no need to call validate independently. Validation is the first\n * thing that is done here.\n *\n * After the extension is validated, it is installed in destinationDirectory\n * unless the extension is already present there. If it is already present,\n * a determination is made about whether the package being installed is\n * an update. If it does appear to be an update, then result.installationStatus\n * is set to NEEDS_UPDATE. If not, then it's set to ALREADY_INSTALLED.\n *\n * If the installation succeeds, then result.installationStatus is set to INSTALLED.\n *\n * The extension is unzipped into a directory in destinationDirectory with\n * the name of the extension (the name is derived either from package.json\n * or the name of the zip file).\n *\n * The destinationDirectory will be created if it does not exist.\n *\n * @param {string} Absolute path to the package zip file\n * @param {string} the destination directory\n * @param {{disabledDirectory: !string, apiVersion: !string, nameHint: ?string,\n *      systemExtensionDirectory: !string}} additional settings to control the installation\n * @param {function} callback (err, result)\n * @param {boolean} _doUpdate  private argument to signal that an update should be performed\n */\nfunction _cmdInstall(packagePath, destinationDirectory, options, callback, _doUpdate) {\n    if (!options || !options.disabledDirectory || !options.apiVersion || !options.systemExtensionDirectory) {\n        callback(new Error(Errors.MISSING_REQUIRED_OPTIONS), null);\n        return;\n    }\n\n    var validateCallback = function (err, validationResult) {\n        validationResult.localPath = packagePath;\n\n        if (destinationDirectory.indexOf(\"/support/\") === 0) {\n            destinationDirectory = path.join(supportDir, destinationDirectory.substr(8));\n        }\n\n        // This is a wrapper for the callback that will delete the temporary\n        // directory to which the package was unzipped.\n        function deleteTempAndCallback(err) {\n            if (validationResult.extractDir) {\n                fs.remove(validationResult.extractDir);\n                delete validationResult.extractDir;\n            }\n            callback(err, validationResult);\n        }\n\n        // If there was trouble at the validation stage, we stop right away.\n        if (err || validationResult.errors.length > 0) {\n            validationResult.installationStatus = Statuses.FAILED;\n            deleteTempAndCallback(err, validationResult);\n            return;\n        }\n\n        // Prefers the package.json name field, but will take the zip\n        // file's name if that's all that's available.\n        var extensionName, guessedName;\n        if (options.nameHint) {\n            guessedName = path.basename(options.nameHint, \".zip\");\n        } else {\n            guessedName = path.basename(packagePath, \".zip\");\n        }\n        if (validationResult.metadata) {\n            extensionName = validationResult.metadata.name;\n        } else {\n            extensionName = guessedName;\n        }\n\n        validationResult.name = extensionName;\n        var installDirectory = path.join(destinationDirectory, extensionName),\n            legacyDirectory = path.join(destinationDirectory, guessedName),\n            systemInstallDirectory = path.join(options.systemExtensionDirectory, extensionName);\n\n        if (validationResult.metadata && validationResult.metadata.engines &&\n                validationResult.metadata.engines.brackets) {\n            var compatible = semver.satisfies(options.apiVersion,\n                                              validationResult.metadata.engines.brackets);\n            if (!compatible) {\n                installDirectory = path.join(options.disabledDirectory, extensionName);\n                validationResult.installationStatus = Statuses.DISABLED;\n                validationResult.disabledReason = Errors.API_NOT_COMPATIBLE;\n                _removeAndInstall(packagePath, installDirectory, validationResult, deleteTempAndCallback);\n                return;\n            }\n        }\n\n        // The \"legacy\" stuff should go away after all of the commonly used extensions\n        // have been upgraded with package.json files.\n        var hasLegacyPackage = validationResult.metadata && legacyPackageCheck(legacyDirectory);\n\n        // If the extension is already there, we signal to the front end that it's already installed\n        // unless the front end has signaled an intent to update.\n        if (hasLegacyPackage || fs.existsSync(installDirectory) || fs.existsSync(systemInstallDirectory)) {\n            if (_doUpdate) {\n                if (hasLegacyPackage) {\n                    // When there's a legacy installed extension, remove it first,\n                    // then also remove any new-style directory the user may have.\n                    // This helps clean up if the user is in a state where they have\n                    // both legacy and new extensions installed.\n                    fs.remove(legacyDirectory, function (err) {\n                        if (err) {\n                            deleteTempAndCallback(err, validationResult);\n                            return;\n                        }\n                        _removeAndInstall(packagePath, installDirectory, validationResult, deleteTempAndCallback);\n                    });\n                } else {\n                    _removeAndInstall(packagePath, installDirectory, validationResult, deleteTempAndCallback);\n                }\n            } else if (hasLegacyPackage) {\n                validationResult.installationStatus = Statuses.NEEDS_UPDATE;\n                validationResult.name = guessedName;\n                deleteTempAndCallback(null, validationResult);\n            } else {\n                _checkExistingInstallation(validationResult, installDirectory, systemInstallDirectory, deleteTempAndCallback);\n            }\n        } else {\n            // Regular installation with no conflicts.\n            validationResult.disabledReason = null;\n            _performInstall(packagePath, installDirectory, validationResult, deleteTempAndCallback);\n        }\n    };\n\n    validate(packagePath, {}, validateCallback);\n}\n\n/**\n * Implements the \"update\" command in the \"extensions\" domain.\n *\n * Currently, this just wraps _cmdInstall, but will remove the existing directory\n * first.\n *\n * There is no need to call validate independently. Validation is the first\n * thing that is done here.\n *\n * After the extension is validated, it is installed in destinationDirectory\n * unless the extension is already present there. If it is already present,\n * a determination is made about whether the package being installed is\n * an update. If it does appear to be an update, then result.installationStatus\n * is set to NEEDS_UPDATE. If not, then it's set to ALREADY_INSTALLED.\n *\n * If the installation succeeds, then result.installationStatus is set to INSTALLED.\n *\n * The extension is unzipped into a directory in destinationDirectory with\n * the name of the extension (the name is derived either from package.json\n * or the name of the zip file).\n *\n * The destinationDirectory will be created if it does not exist.\n *\n * @param {string} Absolute path to the package zip file\n * @param {string} the destination directory\n * @param {{disabledDirectory: !string, apiVersion: !string, nameHint: ?string,\n *      systemExtensionDirectory: !string}} additional settings to control the installation\n * @param {function} callback (err, result)\n */\nfunction _cmdUpdate(packagePath, destinationDirectory, options, callback) {\n    _cmdInstall(packagePath, destinationDirectory, options, callback, true);\n}\n\n/**\n * Wrap up after the given download has terminated (successfully or not). Closes connections, calls back the\n * client's callback, and IF there was an error, delete any partially-downloaded file.\n *\n * @param {string} downloadId Unique id originally passed to _cmdDownloadFile()\n * @param {?string} error If null, download was treated as successful\n */\nfunction _endDownload(downloadId, error) {\n    var downloadInfo = pendingDownloads[downloadId];\n    delete pendingDownloads[downloadId];\n\n    if (error) {\n        // Abort the download if still pending\n        // Note that this will trigger response's \"end\" event\n        downloadInfo.request.abort();\n\n        // Clean up any partially-downloaded file\n        // (if no outStream, then we never got a response back yet and never created any file)\n        if (downloadInfo.outStream) {\n            downloadInfo.outStream.end(function () {\n                fs.unlink(downloadInfo.localPath);\n            });\n        }\n\n        downloadInfo.callback(error, null);\n\n    } else {\n        // Download completed successfully. Flush stream to disk and THEN signal completion\n        downloadInfo.outStream.end(function () {\n            downloadInfo.callback(null, downloadInfo.localPath);\n        });\n    }\n}\n\n/**\n * Implements \"downloadFile\" command, asynchronously.\n */\nfunction _cmdDownloadFile(downloadId, url, proxy, callback) {\n    // Backwards compatibility check, added in 0.37\n    if (typeof proxy === \"function\") {\n        callback = proxy;\n        proxy = undefined;\n    }\n\n    if (pendingDownloads[downloadId]) {\n        callback(Errors.DOWNLOAD_ID_IN_USE, null);\n        return;\n    }\n\n    var https = require(\"https\");\n\n    var req = https.get(url, function(res) {\n        if (res.statusCode !== 200) {\n            _endDownload(downloadId, [Errors.BAD_HTTP_STATUS, res.statusCode]);\n            return;\n        }\n\n        var stream = temp.createWriteStream(\"brackets\");\n        if (!stream) {\n            _endDownload(downloadId, Errors.CANNOT_WRITE_TEMP);\n            return;\n        }\n        pendingDownloads[downloadId].localPath = stream.path;\n        pendingDownloads[downloadId].outStream = stream;\n\n        res.on(\"data\", function(d) {\n            stream.write(d);\n        });\n\n        res.on(\"end\", function () {\n            _endDownload(downloadId);\n        });\n\n    }).on(\"error\", function(e) {\n        console.error(e);\n        _endDownload(downloadId, e.message);\n    });\n\n    pendingDownloads[downloadId] = { request: req, callback: callback };\n}\n\n/**\n * Implements \"abortDownload\" command, synchronously.\n */\nfunction _cmdAbortDownload(downloadId) {\n    if (!pendingDownloads[downloadId]) {\n        // This may mean the download already completed\n        return false;\n    } else {\n        _endDownload(downloadId, Errors.CANCELED);\n        return true;\n    }\n}\n\n/**\n * Implements the remove extension command.\n */\nfunction _cmdRemove(extensionDir, callback) {\n    if (extensionDir.indexOf(\"/support/\") === 0) {\n        extensionDir = path.join(supportDir, extensionDir.substr(8));\n    }\n\n    fs.remove(extensionDir, function (err) {\n        if (err) {\n            callback(err);\n        } else {\n            callback(null);\n        }\n    });\n}\n\n/**\n * Initialize the \"extensions\" domain.\n * The extensions domain handles downloading, unpacking/verifying, and installing extensions.\n */\nfunction init(domainManager) {\n    supportDir = domainManager.supportDir;\n    if (!domainManager.hasDomain(\"extensionManager\")) {\n        domainManager.registerDomain(\"extensionManager\", {major: 0, minor: 1});\n    }\n    domainManager.registerCommand(\n        \"extensionManager\",\n        \"validate\",\n        validate,\n        true,\n        \"Verifies that the contents of the given ZIP file are a valid Brackets extension package\",\n        [{\n            name: \"path\",\n            type: \"string\",\n            description: \"absolute filesystem path of the extension package\"\n        }, {\n            name: \"options\",\n            type: \"{requirePackageJSON: ?boolean}\",\n            description: \"options to control the behavior of the validator\"\n        }],\n        [{\n            name: \"errors\",\n            type: \"string|Array.<string>\",\n            description: \"download error, if any; first string is error code (one of Errors.*); subsequent strings are additional info\"\n        }, {\n            name: \"metadata\",\n            type: \"{name: string, version: string}\",\n            description: \"all package.json metadata (null if there's no package.json)\"\n        }]\n    );\n    domainManager.registerCommand(\n        \"extensionManager\",\n        \"install\",\n        _cmdInstall,\n        true,\n        \"Installs the given Brackets extension if it is valid (runs validation command automatically)\",\n        [{\n            name: \"path\",\n            type: \"string\",\n            description: \"absolute filesystem path of the extension package\"\n        }, {\n            name: \"destinationDirectory\",\n            type: \"string\",\n            description: \"absolute filesystem path where this extension should be installed\"\n        }, {\n            name: \"options\",\n            type: \"{disabledDirectory: !string, apiVersion: !string, nameHint: ?string, systemExtensionDirectory: !string}\",\n            description: \"installation options: disabledDirectory should be set so that extensions can be installed disabled.\"\n        }],\n        [{\n            name: \"errors\",\n            type: \"string|Array.<string>\",\n            description: \"download error, if any; first string is error code (one of Errors.*); subsequent strings are additional info\"\n        }, {\n            name: \"metadata\",\n            type: \"{name: string, version: string}\",\n            description: \"all package.json metadata (null if there's no package.json)\"\n        }, {\n            name: \"disabledReason\",\n            type: \"string\",\n            description: \"reason this extension was installed disabled (one of Errors.*), none if it was enabled\"\n        }, {\n            name: \"installationStatus\",\n            type: \"string\",\n            description: \"Current status of the installation (an extension can be valid but not installed because it's an update\"\n        }, {\n            name: \"installedTo\",\n            type: \"string\",\n            description: \"absolute path where the extension was installed to\"\n        }, {\n            name: \"commonPrefix\",\n            type: \"string\",\n            description: \"top level directory in the package zip which contains all of the files\"\n        }]\n    );\n    domainManager.registerCommand(\n        \"extensionManager\",\n        \"update\",\n        _cmdUpdate,\n        true,\n        \"Updates the given Brackets extension (for which install was generally previously attemped). Brackets must be quit after this.\",\n        [{\n            name: \"path\",\n            type: \"string\",\n            description: \"absolute filesystem path of the extension package\"\n        }, {\n            name: \"destinationDirectory\",\n            type: \"string\",\n            description: \"absolute filesystem path where this extension should be installed\"\n        }, {\n            name: \"options\",\n            type: \"{disabledDirectory: !string, apiVersion: !string, nameHint: ?string, systemExtensionDirectory: !string}\",\n            description: \"installation options: disabledDirectory should be set so that extensions can be installed disabled.\"\n        }],\n        [{\n            name: \"errors\",\n            type: \"string|Array.<string>\",\n            description: \"download error, if any; first string is error code (one of Errors.*); subsequent strings are additional info\"\n        }, {\n            name: \"metadata\",\n            type: \"{name: string, version: string}\",\n            description: \"all package.json metadata (null if there's no package.json)\"\n        }, {\n            name: \"disabledReason\",\n            type: \"string\",\n            description: \"reason this extension was installed disabled (one of Errors.*), none if it was enabled\"\n        }, {\n            name: \"installationStatus\",\n            type: \"string\",\n            description: \"Current status of the installation (an extension can be valid but not installed because it's an update\"\n        }, {\n            name: \"installedTo\",\n            type: \"string\",\n            description: \"absolute path where the extension was installed to\"\n        }, {\n            name: \"commonPrefix\",\n            type: \"string\",\n            description: \"top level directory in the package zip which contains all of the files\"\n        }]\n    );\n    domainManager.registerCommand(\n        \"extensionManager\",\n        \"remove\",\n        _cmdRemove,\n        true,\n        \"Removes the Brackets extension at the given path.\",\n        [{\n            name: \"path\",\n            type: \"string\",\n            description: \"absolute filesystem path of the installed extension folder\"\n        }],\n        {}\n    );\n    domainManager.registerCommand(\n        \"extensionManager\",\n        \"downloadFile\",\n        _cmdDownloadFile,\n        true,\n        \"Downloads the file at the given URL, saving it to a temp location. Callback receives path to the downloaded file.\",\n        [{\n            name: \"downloadId\",\n            type: \"string\",\n            description: \"Unique identifier for this download 'session'\"\n        }, {\n            name: \"url\",\n            type: \"string\",\n            description: \"URL to download from\"\n        }, {\n            name: \"proxy\",\n            type: \"string\",\n            description: \"optional proxy URL\"\n        }],\n        {\n            type: \"string\",\n            description: \"Local path to the downloaded file\"\n        }\n    );\n    domainManager.registerCommand(\n        \"extensionManager\",\n        \"abortDownload\",\n        _cmdAbortDownload,\n        false,\n        \"Aborts any pending download with the given id. Ignored if no download pending (may be already complete).\",\n        [{\n            name: \"downloadId\",\n            type: \"string\",\n            description: \"Unique identifier for this download 'session', previously pased to downloadFile\"\n        }],\n        {\n            type: \"boolean\",\n            description: \"True if the download was pending and able to be canceled; false otherwise\"\n        }\n    );\n}\n\n// used in unit tests\nexports._cmdValidate = validate;\nexports._cmdInstall = _cmdInstall;\nexports._cmdRemove = _cmdRemove;\nexports._cmdUpdate = _cmdUpdate;\n\n// used to load the domain\nexports.init = init;\n","/home/travis/build/npmtest/node-npmtest-brackets/node_modules/brackets/brackets-srv/extensibility/node/ExtensionManagerDomain.js":"/*\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n */\n\n\n/*jslint vars: true, plusplus: true, devel: true, node: true, nomen: true,\nindent: 4, maxerr: 50 */\n\n\"use strict\";\n\nvar supportDir;\n\nvar semver   = require(\"semver\"),\n    path     = require(\"path\"),\n    http     = require(\"http\"),\n    request  = require(\"request\"),\n    os       = require(\"os\"),\n    fs       = require(\"fs-extra\"),\n    temp     = require(\"temp\"),\n    validate = require(\"./package-validator\").validate;\n\n// Automatically clean up temp files on exit\ntemp.track();\n\nvar Errors = {\n    API_NOT_COMPATIBLE: \"API_NOT_COMPATIBLE\",\n    MISSING_REQUIRED_OPTIONS: \"MISSING_REQUIRED_OPTIONS\",\n    DOWNLOAD_ID_IN_USE: \"DOWNLOAD_ID_IN_USE\",\n    BAD_HTTP_STATUS: \"BAD_HTTP_STATUS\",             // {0} is the HTTP status code\n    NO_SERVER_RESPONSE: \"NO_SERVER_RESPONSE\",\n    CANNOT_WRITE_TEMP: \"CANNOT_WRITE_TEMP\",\n    CANCELED: \"CANCELED\"\n};\n\nvar Statuses = {\n    FAILED: \"FAILED\",\n    INSTALLED: \"INSTALLED\",\n    ALREADY_INSTALLED: \"ALREADY_INSTALLED\",\n    SAME_VERSION: \"SAME_VERSION\",\n    OLDER_VERSION: \"OLDER_VERSION\",\n    NEEDS_UPDATE: \"NEEDS_UPDATE\",\n    DISABLED: \"DISABLED\"\n};\n\n/**\n * Maps unique download ID to info about the pending download. No entry if download no longer pending.\n * outStream is only present if we've started receiving the body.\n * @type {Object.<string, {request:!http.ClientRequest, callback:!function(string, string), localPath:string, outStream:?fs.WriteStream}>}\n */\nvar pendingDownloads = {};\n\n/**\n * Private function to remove the installation directory if the installation fails.\n * This does not call any callbacks. It's assumed that the callback has already been called\n * and this cleanup routine will do its best to complete in the background. If there's\n * a problem here, it is simply logged with console.error.\n *\n * @param {string} installDirectory Directory to remove\n */\nfunction _removeFailedInstallation(installDirectory) {\n    fs.remove(installDirectory, function (err) {\n        if (err) {\n            console.error(\"Error while removing directory after failed installation\", installDirectory, err);\n        }\n    });\n}\n\n/**\n * Private function to unzip to the correct directory.\n *\n * @param {string} Absolute path to the package zip file\n * @param {string} Absolute path to the destination directory for unzipping\n * @param {Object} the return value with the useful information for the client\n * @param {Function} callback function that is called at the end of the unzipping\n */\nfunction _performInstall(packagePath, installDirectory, validationResult, callback) {\n    validationResult.installedTo = installDirectory;\n\n    var callbackCalled = false;\n\n    fs.mkdirs(installDirectory, function (err) {\n        if (err) {\n            callback(err);\n            return;\n        }\n        var sourceDir = path.join(validationResult.extractDir, validationResult.commonPrefix);\n\n        fs.copy(sourceDir, installDirectory, function (err) {\n            if (err) {\n                _removeFailedInstallation(installDirectory);\n                callback(err, null);\n            } else {\n                // The status may have already been set previously (as in the\n                // DISABLED case.\n                if (!validationResult.installationStatus) {\n                    validationResult.installationStatus = Statuses.INSTALLED;\n                }\n                callback(null, validationResult);\n            }\n        });\n    });\n}\n\n/**\n * Private function to remove the target directory and then install.\n *\n * @param {string} Absolute path to the package zip file\n * @param {string} Absolute path to the destination directory for unzipping\n * @param {Object} the return value with the useful information for the client\n * @param {Function} callback function that is called at the end of the unzipping\n */\nfunction _removeAndInstall(packagePath, installDirectory, validationResult, callback) {\n    // If this extension was previously installed but disabled, we will overwrite the\n    // previous installation in that directory.\n    fs.remove(installDirectory, function (err) {\n        if (err) {\n            callback(err);\n            return;\n        }\n        _performInstall(packagePath, installDirectory, validationResult, callback);\n    });\n}\n\nfunction _checkExistingInstallation(validationResult, installDirectory, systemInstallDirectory, callback) {\n    // If the extension being installed does not have a package.json, we can't\n    // do any kind of version comparison, so we just signal to the UI that\n    // it already appears to be installed.\n    if (!validationResult.metadata) {\n        validationResult.installationStatus = Statuses.ALREADY_INSTALLED;\n        callback(null, validationResult);\n        return;\n    }\n\n    fs.readJson(path.join(installDirectory, \"package.json\"), function (err, packageObj) {\n        // if the package.json is unreadable, we assume that the new package is an update\n        // that is the first to include a package.json.\n        if (err) {\n            validationResult.installationStatus = Statuses.NEEDS_UPDATE;\n        } else {\n            // Check to see if the version numbers signal an update.\n            if (semver.lt(packageObj.version, validationResult.metadata.version)) {\n                validationResult.installationStatus = Statuses.NEEDS_UPDATE;\n            } else if (semver.gt(packageObj.version, validationResult.metadata.version)) {\n                // Pass a message back to the UI that the new package appears to be an older version\n                // than what's installed.\n                validationResult.installationStatus = Statuses.OLDER_VERSION;\n                validationResult.installedVersion = packageObj.version;\n            } else {\n                // Signal to the UI that it looks like the user is re-installing the\n                // same version.\n                validationResult.installationStatus = Statuses.SAME_VERSION;\n            }\n        }\n        callback(null, validationResult);\n    });\n}\n\n/**\n * A \"legacy package\" is an extension that was installed based on the GitHub name without\n * a package.json file. Checking for the presence of these legacy extensions will help\n * users upgrade if the extension developer puts a different name in package.json than\n * the name of the GitHub project.\n *\n * @param {string} legacyDirectory directory to check for old-style extension.\n */\nfunction legacyPackageCheck(legacyDirectory) {\n    return fs.existsSync(legacyDirectory) && !fs.existsSync(path.join(legacyDirectory, \"package.json\"));\n}\n\n/**\n * Implements the \"install\" command in the \"extensions\" domain.\n *\n * There is no need to call validate independently. Validation is the first\n * thing that is done here.\n *\n * After the extension is validated, it is installed in destinationDirectory\n * unless the extension is already present there. If it is already present,\n * a determination is made about whether the package being installed is\n * an update. If it does appear to be an update, then result.installationStatus\n * is set to NEEDS_UPDATE. If not, then it's set to ALREADY_INSTALLED.\n *\n * If the installation succeeds, then result.installationStatus is set to INSTALLED.\n *\n * The extension is unzipped into a directory in destinationDirectory with\n * the name of the extension (the name is derived either from package.json\n * or the name of the zip file).\n *\n * The destinationDirectory will be created if it does not exist.\n *\n * @param {string} Absolute path to the package zip file\n * @param {string} the destination directory\n * @param {{disabledDirectory: !string, apiVersion: !string, nameHint: ?string,\n *      systemExtensionDirectory: !string}} additional settings to control the installation\n * @param {function} callback (err, result)\n * @param {boolean} _doUpdate  private argument to signal that an update should be performed\n */\nfunction _cmdInstall(packagePath, destinationDirectory, options, callback, _doUpdate) {\n    if (!options || !options.disabledDirectory || !options.apiVersion || !options.systemExtensionDirectory) {\n        callback(new Error(Errors.MISSING_REQUIRED_OPTIONS), null);\n        return;\n    }\n\n    var validateCallback = function (err, validationResult) {\n        validationResult.localPath = packagePath;\n\n        if (destinationDirectory.indexOf(\"/support/\") === 0) {\n            destinationDirectory = path.join(supportDir, destinationDirectory.substr(8));\n        }\n\n        // This is a wrapper for the callback that will delete the temporary\n        // directory to which the package was unzipped.\n        function deleteTempAndCallback(err) {\n            if (validationResult.extractDir) {\n                fs.remove(validationResult.extractDir);\n                delete validationResult.extractDir;\n            }\n            callback(err, validationResult);\n        }\n\n        // If there was trouble at the validation stage, we stop right away.\n        if (err || validationResult.errors.length > 0) {\n            validationResult.installationStatus = Statuses.FAILED;\n            deleteTempAndCallback(err, validationResult);\n            return;\n        }\n\n        // Prefers the package.json name field, but will take the zip\n        // file's name if that's all that's available.\n        var extensionName, guessedName;\n        if (options.nameHint) {\n            guessedName = path.basename(options.nameHint, \".zip\");\n        } else {\n            guessedName = path.basename(packagePath, \".zip\");\n        }\n        if (validationResult.metadata) {\n            extensionName = validationResult.metadata.name;\n        } else {\n            extensionName = guessedName;\n        }\n\n        validationResult.name = extensionName;\n        var installDirectory = path.join(destinationDirectory, extensionName),\n            legacyDirectory = path.join(destinationDirectory, guessedName),\n            systemInstallDirectory = path.join(options.systemExtensionDirectory, extensionName);\n\n        if (validationResult.metadata && validationResult.metadata.engines &&\n                validationResult.metadata.engines.brackets) {\n            var compatible = semver.satisfies(options.apiVersion,\n                                              validationResult.metadata.engines.brackets);\n            if (!compatible) {\n                installDirectory = path.join(options.disabledDirectory, extensionName);\n                validationResult.installationStatus = Statuses.DISABLED;\n                validationResult.disabledReason = Errors.API_NOT_COMPATIBLE;\n                _removeAndInstall(packagePath, installDirectory, validationResult, deleteTempAndCallback);\n                return;\n            }\n        }\n\n        // The \"legacy\" stuff should go away after all of the commonly used extensions\n        // have been upgraded with package.json files.\n        var hasLegacyPackage = validationResult.metadata && legacyPackageCheck(legacyDirectory);\n\n        // If the extension is already there, we signal to the front end that it's already installed\n        // unless the front end has signaled an intent to update.\n        if (hasLegacyPackage || fs.existsSync(installDirectory) || fs.existsSync(systemInstallDirectory)) {\n            if (_doUpdate) {\n                if (hasLegacyPackage) {\n                    // When there's a legacy installed extension, remove it first,\n                    // then also remove any new-style directory the user may have.\n                    // This helps clean up if the user is in a state where they have\n                    // both legacy and new extensions installed.\n                    fs.remove(legacyDirectory, function (err) {\n                        if (err) {\n                            deleteTempAndCallback(err, validationResult);\n                            return;\n                        }\n                        _removeAndInstall(packagePath, installDirectory, validationResult, deleteTempAndCallback);\n                    });\n                } else {\n                    _removeAndInstall(packagePath, installDirectory, validationResult, deleteTempAndCallback);\n                }\n            } else if (hasLegacyPackage) {\n                validationResult.installationStatus = Statuses.NEEDS_UPDATE;\n                validationResult.name = guessedName;\n                deleteTempAndCallback(null, validationResult);\n            } else {\n                _checkExistingInstallation(validationResult, installDirectory, systemInstallDirectory, deleteTempAndCallback);\n            }\n        } else {\n            // Regular installation with no conflicts.\n            validationResult.disabledReason = null;\n            _performInstall(packagePath, installDirectory, validationResult, deleteTempAndCallback);\n        }\n    };\n\n    validate(packagePath, {}, validateCallback);\n}\n\n/**\n * Implements the \"update\" command in the \"extensions\" domain.\n *\n * Currently, this just wraps _cmdInstall, but will remove the existing directory\n * first.\n *\n * There is no need to call validate independently. Validation is the first\n * thing that is done here.\n *\n * After the extension is validated, it is installed in destinationDirectory\n * unless the extension is already present there. If it is already present,\n * a determination is made about whether the package being installed is\n * an update. If it does appear to be an update, then result.installationStatus\n * is set to NEEDS_UPDATE. If not, then it's set to ALREADY_INSTALLED.\n *\n * If the installation succeeds, then result.installationStatus is set to INSTALLED.\n *\n * The extension is unzipped into a directory in destinationDirectory with\n * the name of the extension (the name is derived either from package.json\n * or the name of the zip file).\n *\n * The destinationDirectory will be created if it does not exist.\n *\n * @param {string} Absolute path to the package zip file\n * @param {string} the destination directory\n * @param {{disabledDirectory: !string, apiVersion: !string, nameHint: ?string,\n *      systemExtensionDirectory: !string}} additional settings to control the installation\n * @param {function} callback (err, result)\n */\nfunction _cmdUpdate(packagePath, destinationDirectory, options, callback) {\n    _cmdInstall(packagePath, destinationDirectory, options, callback, true);\n}\n\n/**\n * Wrap up after the given download has terminated (successfully or not). Closes connections, calls back the\n * client's callback, and IF there was an error, delete any partially-downloaded file.\n *\n * @param {string} downloadId Unique id originally passed to _cmdDownloadFile()\n * @param {?string} error If null, download was treated as successful\n */\nfunction _endDownload(downloadId, error) {\n    var downloadInfo = pendingDownloads[downloadId];\n    delete pendingDownloads[downloadId];\n\n    if (error) {\n        // Abort the download if still pending\n        // Note that this will trigger response's \"end\" event\n        downloadInfo.request.abort();\n\n        // Clean up any partially-downloaded file\n        // (if no outStream, then we never got a response back yet and never created any file)\n        if (downloadInfo.outStream) {\n            downloadInfo.outStream.end(function () {\n                fs.unlink(downloadInfo.localPath);\n            });\n        }\n\n        downloadInfo.callback(error, null);\n\n    } else {\n        // Download completed successfully. Flush stream to disk and THEN signal completion\n        downloadInfo.outStream.end(function () {\n            downloadInfo.callback(null, downloadInfo.localPath);\n        });\n    }\n}\n\n/**\n * Implements \"downloadFile\" command, asynchronously.\n */\nfunction _cmdDownloadFile(downloadId, url, proxy, callback) {\n    // Backwards compatibility check, added in 0.37\n    if (typeof proxy === \"function\") {\n        callback = proxy;\n        proxy = undefined;\n    }\n\n    if (pendingDownloads[downloadId]) {\n        callback(Errors.DOWNLOAD_ID_IN_USE, null);\n        return;\n    }\n\n    var https = require(\"https\");\n\n    var req = https.get(url, function(res) {\n        if (res.statusCode !== 200) {\n            _endDownload(downloadId, [Errors.BAD_HTTP_STATUS, res.statusCode]);\n            return;\n        }\n\n        var stream = temp.createWriteStream(\"brackets\");\n        if (!stream) {\n            _endDownload(downloadId, Errors.CANNOT_WRITE_TEMP);\n            return;\n        }\n        pendingDownloads[downloadId].localPath = stream.path;\n        pendingDownloads[downloadId].outStream = stream;\n\n        res.on(\"data\", function(d) {\n            stream.write(d);\n        });\n\n        res.on(\"end\", function () {\n            _endDownload(downloadId);\n        });\n\n    }).on(\"error\", function(e) {\n        console.error(e);\n        _endDownload(downloadId, e.message);\n    });\n\n    pendingDownloads[downloadId] = { request: req, callback: callback };\n}\n\n/**\n * Implements \"abortDownload\" command, synchronously.\n */\nfunction _cmdAbortDownload(downloadId) {\n    if (!pendingDownloads[downloadId]) {\n        // This may mean the download already completed\n        return false;\n    } else {\n        _endDownload(downloadId, Errors.CANCELED);\n        return true;\n    }\n}\n\n/**\n * Implements the remove extension command.\n */\nfunction _cmdRemove(extensionDir, callback) {\n    if (extensionDir.indexOf(\"/support/\") === 0) {\n        extensionDir = path.join(supportDir, extensionDir.substr(8));\n    }\n\n    fs.remove(extensionDir, function (err) {\n        if (err) {\n            callback(err);\n        } else {\n            callback(null);\n        }\n    });\n}\n\n/**\n * Initialize the \"extensions\" domain.\n * The extensions domain handles downloading, unpacking/verifying, and installing extensions.\n */\nfunction init(domainManager) {\n    supportDir = domainManager.supportDir;\n    if (!domainManager.hasDomain(\"extensionManager\")) {\n        domainManager.registerDomain(\"extensionManager\", {major: 0, minor: 1});\n    }\n    domainManager.registerCommand(\n        \"extensionManager\",\n        \"validate\",\n        validate,\n        true,\n        \"Verifies that the contents of the given ZIP file are a valid Brackets extension package\",\n        [{\n            name: \"path\",\n            type: \"string\",\n            description: \"absolute filesystem path of the extension package\"\n        }, {\n            name: \"options\",\n            type: \"{requirePackageJSON: ?boolean}\",\n            description: \"options to control the behavior of the validator\"\n        }],\n        [{\n            name: \"errors\",\n            type: \"string|Array.<string>\",\n            description: \"download error, if any; first string is error code (one of Errors.*); subsequent strings are additional info\"\n        }, {\n            name: \"metadata\",\n            type: \"{name: string, version: string}\",\n            description: \"all package.json metadata (null if there's no package.json)\"\n        }]\n    );\n    domainManager.registerCommand(\n        \"extensionManager\",\n        \"install\",\n        _cmdInstall,\n        true,\n        \"Installs the given Brackets extension if it is valid (runs validation command automatically)\",\n        [{\n            name: \"path\",\n            type: \"string\",\n            description: \"absolute filesystem path of the extension package\"\n        }, {\n            name: \"destinationDirectory\",\n            type: \"string\",\n            description: \"absolute filesystem path where this extension should be installed\"\n        }, {\n            name: \"options\",\n            type: \"{disabledDirectory: !string, apiVersion: !string, nameHint: ?string, systemExtensionDirectory: !string}\",\n            description: \"installation options: disabledDirectory should be set so that extensions can be installed disabled.\"\n        }],\n        [{\n            name: \"errors\",\n            type: \"string|Array.<string>\",\n            description: \"download error, if any; first string is error code (one of Errors.*); subsequent strings are additional info\"\n        }, {\n            name: \"metadata\",\n            type: \"{name: string, version: string}\",\n            description: \"all package.json metadata (null if there's no package.json)\"\n        }, {\n            name: \"disabledReason\",\n            type: \"string\",\n            description: \"reason this extension was installed disabled (one of Errors.*), none if it was enabled\"\n        }, {\n            name: \"installationStatus\",\n            type: \"string\",\n            description: \"Current status of the installation (an extension can be valid but not installed because it's an update\"\n        }, {\n            name: \"installedTo\",\n            type: \"string\",\n            description: \"absolute path where the extension was installed to\"\n        }, {\n            name: \"commonPrefix\",\n            type: \"string\",\n            description: \"top level directory in the package zip which contains all of the files\"\n        }]\n    );\n    domainManager.registerCommand(\n        \"extensionManager\",\n        \"update\",\n        _cmdUpdate,\n        true,\n        \"Updates the given Brackets extension (for which install was generally previously attemped). Brackets must be quit after this.\",\n        [{\n            name: \"path\",\n            type: \"string\",\n            description: \"absolute filesystem path of the extension package\"\n        }, {\n            name: \"destinationDirectory\",\n            type: \"string\",\n            description: \"absolute filesystem path where this extension should be installed\"\n        }, {\n            name: \"options\",\n            type: \"{disabledDirectory: !string, apiVersion: !string, nameHint: ?string, systemExtensionDirectory: !string}\",\n            description: \"installation options: disabledDirectory should be set so that extensions can be installed disabled.\"\n        }],\n        [{\n            name: \"errors\",\n            type: \"string|Array.<string>\",\n            description: \"download error, if any; first string is error code (one of Errors.*); subsequent strings are additional info\"\n        }, {\n            name: \"metadata\",\n            type: \"{name: string, version: string}\",\n            description: \"all package.json metadata (null if there's no package.json)\"\n        }, {\n            name: \"disabledReason\",\n            type: \"string\",\n            description: \"reason this extension was installed disabled (one of Errors.*), none if it was enabled\"\n        }, {\n            name: \"installationStatus\",\n            type: \"string\",\n            description: \"Current status of the installation (an extension can be valid but not installed because it's an update\"\n        }, {\n            name: \"installedTo\",\n            type: \"string\",\n            description: \"absolute path where the extension was installed to\"\n        }, {\n            name: \"commonPrefix\",\n            type: \"string\",\n            description: \"top level directory in the package zip which contains all of the files\"\n        }]\n    );\n    domainManager.registerCommand(\n        \"extensionManager\",\n        \"remove\",\n        _cmdRemove,\n        true,\n        \"Removes the Brackets extension at the given path.\",\n        [{\n            name: \"path\",\n            type: \"string\",\n            description: \"absolute filesystem path of the installed extension folder\"\n        }],\n        {}\n    );\n    domainManager.registerCommand(\n        \"extensionManager\",\n        \"downloadFile\",\n        _cmdDownloadFile,\n        true,\n        \"Downloads the file at the given URL, saving it to a temp location. Callback receives path to the downloaded file.\",\n        [{\n            name: \"downloadId\",\n            type: \"string\",\n            description: \"Unique identifier for this download 'session'\"\n        }, {\n            name: \"url\",\n            type: \"string\",\n            description: \"URL to download from\"\n        }, {\n            name: \"proxy\",\n            type: \"string\",\n            description: \"optional proxy URL\"\n        }],\n        {\n            type: \"string\",\n            description: \"Local path to the downloaded file\"\n        }\n    );\n    domainManager.registerCommand(\n        \"extensionManager\",\n        \"abortDownload\",\n        _cmdAbortDownload,\n        false,\n        \"Aborts any pending download with the given id. Ignored if no download pending (may be already complete).\",\n        [{\n            name: \"downloadId\",\n            type: \"string\",\n            description: \"Unique identifier for this download 'session', previously pased to downloadFile\"\n        }],\n        {\n            type: \"boolean\",\n            description: \"True if the download was pending and able to be canceled; false otherwise\"\n        }\n    );\n}\n\n// used in unit tests\nexports._cmdValidate = validate;\nexports._cmdInstall = _cmdInstall;\nexports._cmdRemove = _cmdRemove;\nexports._cmdUpdate = _cmdUpdate;\n\n// used to load the domain\nexports.init = init;\n","/home/travis/build/npmtest/node-npmtest-brackets/node_modules/brackets/brackets-srv/extensibility/node/package-validator.js":"/*\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n *  \n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"), \n * to deal in the Software without restriction, including without limitation \n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \n * and/or sell copies of the Software, and to permit persons to whom the \n * Software is furnished to do so, subject to the following conditions:\n *  \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *  \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \n * DEALINGS IN THE SOFTWARE.\n * \n */\n\n\n/*jslint vars: true, plusplus: true, devel: true, node: true, nomen: true,\nindent: 4, maxerr: 50, regexp: true */\n\n\"use strict\";\n\nvar DecompressZip = require(\"decompress-zip\"),\n    semver        = require(\"semver\"),\n    path          = require(\"path\"),\n    temp          = require(\"temp\"),\n    fs            = require(\"fs-extra\");\n\n// Track and cleanup files at exit\ntemp.track();\n\nvar Errors = {\n    NOT_FOUND_ERR: \"NOT_FOUND_ERR\",                       // {0} is path where ZIP file was expected\n    INVALID_ZIP_FILE: \"INVALID_ZIP_FILE\",                 // {0} is path to ZIP file\n    INVALID_PACKAGE_JSON: \"INVALID_PACKAGE_JSON\",         // {0} is JSON parse error, {1} is path to ZIP file\n    MISSING_PACKAGE_NAME: \"MISSING_PACKAGE_NAME\",         // {0} is path to ZIP file\n    BAD_PACKAGE_NAME: \"BAD_PACKAGE_NAME\",                 // {0} is the name\n    MISSING_PACKAGE_VERSION: \"MISSING_PACKAGE_VERSION\",   // {0} is path to ZIP file\n    INVALID_VERSION_NUMBER: \"INVALID_VERSION_NUMBER\",     // {0} is version string in JSON, {1} is path to ZIP file\n    MISSING_MAIN: \"MISSING_MAIN\",                         // {0} is path to ZIP file\n    MISSING_PACKAGE_JSON: \"MISSING_PACKAGE_JSON\",         // {0} is path to ZIP file\n    INVALID_BRACKETS_VERSION: \"INVALID_BRACKETS_VERSION\", // {0} is the version string in JSON, {1} is the path to the zip file,\n    DISALLOWED_WORDS: \"DISALLOWED_WORDS\"                  // {0} is the field with the word, {1} is a string list of words that were in violation, {2} is the path to the zip file\n};\n\n/*\n * Directories to ignore when determining whether the contents of an extension are\n * in a subfolder.\n */\nvar ignoredFolders = [ \"__MACOSX\" ];\n\n/**\n * Returns true if the name presented is acceptable as a package name. This enforces the\n * requirement as presented in the CommonJS spec: http://wiki.commonjs.org/wiki/Packages/1.0\n * which states:\n *\n * \"This must be a unique, lowercase alpha-numeric name without spaces. It may include \".\" or \"_\" or \"-\" characters.\"\n *\n * We add the additional requirement that the first character must be a letter or number\n * (there's a security implication to allowing a name like \"..\", because the name is\n * used in directory names).\n *\n * @param {string} name to test\n * @return {boolean} true if the name is valid\n */\nfunction validateName(name) {\n    if (/^[a-z0-9][a-z0-9._\\-]*$/.exec(name)) {\n        return true;\n    }\n    return false;\n}\n\n// Parses strings of the form \"name <email> (url)\" where email and url are optional\nvar _personRegex = /^([^<\\(]+)(?:\\s+<([^>]+)>)?(?:\\s+\\(([^\\)]+)\\))?$/;\n\n/**\n * Normalizes person fields from package.json.\n *\n * These fields can be an object with name, email and url properties or a\n * string of the form \"name <email> <url>\". This does a tolerant parsing of\n * the data to try to return an object with name and optional email and url.\n * If the string does not match the format, the string is returned as the\n * name on the resulting object.\n *\n * If an object other than a string is passed in, it's returned as is.\n *\n * @param <String|Object> obj to normalize\n * @return {Object} person object with name and optional email and url\n */\nfunction parsePersonString(obj) {\n    if (typeof (obj) === \"string\") {\n        var parts = _personRegex.exec(obj);\n        \n        // No regex match, so we just synthesize an object with an opaque name string\n        if (!parts) {\n            return {\n                name: obj\n            };\n        } else {\n            var result = {\n                name: parts[1]\n            };\n            if (parts[2]) {\n                result.email = parts[2];\n            }\n            if (parts[3]) {\n                result.url = parts[3];\n            }\n            return result;\n        }\n    } else {\n        // obj is not a string, so return as is\n        return obj;\n    }\n}\n\n/**\n * Determines if any of the words in wordlist appear in str.\n *\n * @param {String[]} wordlist list of words to check\n * @param {String} str to check for words\n * @return {String[]} words that matched\n */\nfunction containsWords(wordlist, str) {\n    var i;\n    var matches = [];\n    for (i = 0; i < wordlist.length; i++) {\n        var re = new RegExp(\"\\\\b\" + wordlist[i] + \"\\\\b\", \"i\");\n        if (re.exec(str)) {\n            matches.push(wordlist[i]);\n        }\n    }\n    return matches;\n}\n\n/**\n * Finds the common prefix, if any, for the files in a package file.\n *\n * In some package files, all of the files are contained in a subdirectory, and this function\n * will identify that directory if it exists.\n *\n * @param {string} extractDir directory into which the package was extracted\n * @param {function(Error, string)} callback function to accept err, commonPrefix (which will be \"\" if there is none)\n */\nfunction findCommonPrefix(extractDir, callback) {\n    fs.readdir(extractDir, function (err, files) {\n        ignoredFolders.forEach(function (folder) {\n            var index = files.indexOf(folder);\n            if (index !== -1) {\n                files.splice(index, 1);\n            }\n        });\n        if (err) {\n            callback(err);\n        } else if (files.length === 1) {\n            var name = files[0];\n            if (fs.statSync(path.join(extractDir, name)).isDirectory()) {\n                callback(null, name);\n            } else {\n                callback(null, \"\");\n            }\n        } else {\n            callback(null, \"\");\n        }\n    });\n}\n\n/**\n * Validates the contents of package.json.\n *\n * @param {string} path path to package file (used in error reporting)\n * @param {string} packageJSON path to the package.json file to check\n * @param {Object} options validation options passed to `validate()`\n * @param {function(Error, Array.<Array.<string, ...>>, Object)} callback function to call with array of errors and metadata\n */\nfunction validatePackageJSON(path, packageJSON, options, callback) {\n    var errors = [];\n    if (fs.existsSync(packageJSON)) {\n        fs.readFile(packageJSON, {\n            encoding: \"utf8\"\n        }, function (err, data) {\n            if (err) {\n                callback(err, null, null);\n                return;\n            }\n            \n            var metadata;\n            \n            try {\n                metadata = JSON.parse(data);\n            } catch (e) {\n                errors.push([Errors.INVALID_PACKAGE_JSON, e.toString(), path]);\n                callback(null, errors, undefined);\n                return;\n            }\n            \n            // confirm required fields in the metadata\n            if (!metadata.name) {\n                errors.push([Errors.MISSING_PACKAGE_NAME, path]);\n            } else if (!validateName(metadata.name)) {\n                errors.push([Errors.BAD_PACKAGE_NAME, metadata.name]);\n            }\n            if (!metadata.version) {\n                errors.push([Errors.MISSING_PACKAGE_VERSION, path]);\n            } else if (!semver.valid(metadata.version)) {\n                errors.push([Errors.INVALID_VERSION_NUMBER, metadata.version, path]);\n            }\n            \n            // normalize the author\n            if (metadata.author) {\n                metadata.author = parsePersonString(metadata.author);\n            }\n            \n            // contributors should be an array of people.\n            // normalize each entry.\n            if (metadata.contributors) {\n                if (metadata.contributors.map) {\n                    metadata.contributors = metadata.contributors.map(function (person) {\n                        return parsePersonString(person);\n                    });\n                } else {\n                    metadata.contributors = [\n                        parsePersonString(metadata.contributors)\n                    ];\n                }\n            }\n            \n            if (metadata.engines && metadata.engines.brackets) {\n                var range = metadata.engines.brackets;\n                if (!semver.validRange(range)) {\n                    errors.push([Errors.INVALID_BRACKETS_VERSION, range, path]);\n                }\n            }\n            \n            if (options.disallowedWords) {\n                [\"title\", \"description\", \"name\"].forEach(function (field) {\n                    var words = containsWords(options.disallowedWords, metadata[field]);\n                    if (words.length > 0) {\n                        errors.push([Errors.DISALLOWED_WORDS, field, words.toString(), path]);\n                    }\n                });\n            }\n            callback(null, errors, metadata);\n        });\n    } else {\n        if (options.requirePackageJSON) {\n            errors.push([Errors.MISSING_PACKAGE_JSON, path]);\n        }\n        callback(null, errors, null);\n    }\n}\n\n/**\n * Extracts the package into the given directory and then validates it.\n *\n * @param {string} zipPath path to package zip file\n * @param {string} extractDir directory to extract package into\n * @param {Object} options validation options\n * @param {function(Error, {errors: Array, metadata: Object, commonPrefix: string, extractDir: string})} callback function to call with the result\n */\nfunction extractAndValidateFiles(zipPath, extractDir, options, callback) {\n    var unzipper = new DecompressZip(zipPath);\n    unzipper.on(\"error\", function (err) {\n        // General error to report for problems reading the file\n        callback(null, {\n            errors: [[Errors.INVALID_ZIP_FILE, zipPath, err]]\n        });\n        return;\n    });\n    \n    unzipper.on(\"extract\", function (log) {\n        findCommonPrefix(extractDir, function (err, commonPrefix) {\n            if (err) {\n                callback(err, null);\n                return;\n            }\n            var packageJSON = path.join(extractDir, commonPrefix, \"package.json\");\n            validatePackageJSON(zipPath, packageJSON, options, function (err, errors, metadata) {\n                if (err) {\n                    callback(err, null);\n                    return;\n                }\n                var mainJS  = path.join(extractDir, commonPrefix, \"main.js\"),\n                    isTheme = metadata && metadata.theme;\n                \n                // Throw missing main.js file only for non-theme extensions\n                if (!isTheme && !fs.existsSync(mainJS)) {\n                    errors.push([Errors.MISSING_MAIN, zipPath, mainJS]);\n                }\n                callback(null, {\n                    errors: errors,\n                    metadata: metadata,\n                    commonPrefix: commonPrefix,\n                    extractDir: extractDir\n                });\n            });\n        });\n    });\n    \n    unzipper.extract({\n        path: extractDir,\n        filter: function (file) {\n            return file.type !== \"SymbolicLink\";\n        }\n    });\n}\n\n/**\n * Implements the \"validate\" command in the \"extensions\" domain.\n * Validates the zipped package at path.\n *\n * The \"err\" parameter of the callback is only set if there was an\n * unexpected error. Otherwise, errors are reported in the result.\n *\n * The result object has an \"errors\" property. It is an array of\n * arrays of strings. Each array in the array is a set of parameters\n * that can be passed to StringUtils.format for internationalization.\n * The array will be empty if there are no errors.\n *\n * The result will have a \"metadata\" property if the metadata was\n * read successfully from package.json in the zip file.\n *\n * @param {string} path Absolute path to the package zip file\n * @param {{requirePackageJSON: ?boolean, disallowedWords: ?Array.<string>}} options for validation\n * @param {function} callback (err, result)\n */\nfunction validate(path, options, callback) {\n    options = options || {};\n    fs.exists(path, function (doesExist) {\n        if (!doesExist) {\n            callback(null, {\n                errors: [[Errors.NOT_FOUND_ERR, path]]\n            });\n            return;\n        }\n        temp.mkdir(\"bracketsPackage_\", function _tempDirCreated(err, extractDir) {\n            if (err) {\n                callback(err, null);\n                return;\n            }\n            extractAndValidateFiles(path, extractDir, options, callback);\n        });\n    });\n}\n\n// exported for unit testing\nexports._parsePersonString = parsePersonString;\n\nexports.errors = Errors;\nexports.validate = validate;\n"}